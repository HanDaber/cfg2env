package converter

import (
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/handaber/cfg2env/plugin"
)

// Converter handles the conversion of configuration files to .env format
type Converter struct {
	plugin  plugin.Plugin
	version string
}

// New creates a new Converter with the given plugin
func New(p plugin.Plugin) *Converter {
	return &Converter{
		plugin:  p,
		version: "dev", // This will be overridden by the version from main
	}
}

// SetVersion sets the version string for the converter
func (c *Converter) SetVersion(version string) {
	c.version = version
}

func (c *Converter) writeHeader(w io.Writer) error {
	header := []string{
		"# This file was auto-generated by cfg2env",
		fmt.Sprintf("# Version: %s", c.version),
		fmt.Sprintf("# Plugin: %s", c.plugin.Name()),
		"#",
		"",
	}

	for _, line := range header {
		if _, err := io.WriteString(w, line+"\n"); err != nil {
			return fmt.Errorf("writing header error: %w", err)
		}
	}
	return nil
}

// Convert reads from r and writes the converted output to w
func (c *Converter) Convert(r io.Reader, w io.Writer) error {
	// Handle nil input/output
	if r == nil {
		return fmt.Errorf("input reader is nil")
	}
	if w == nil {
		return fmt.Errorf("output writer is nil")
	}

	// Write header first
	if err := c.writeHeader(w); err != nil {
		return err
	}

	// Parse input using plugin
	env, err := c.plugin.Parse(r)
	if err != nil {
		return fmt.Errorf("parsing error: %w", err)
	}

	// Convert all keys to uppercase and merge duplicate keys
	normalized := make(map[string]string)
	for k, v := range env {
		upperKey := strings.ToUpper(k)
		normalized[upperKey] = v
	}

	// Get sorted keys for consistent output
	var keys []string
	for k := range normalized {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Write output in .env format
	for _, k := range keys {
		if _, err := io.WriteString(w, k+"="+normalized[k]+"\n"); err != nil {
			return fmt.Errorf("writing error: %w", err)
		}
	}

	return nil
}
