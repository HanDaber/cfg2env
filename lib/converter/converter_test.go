package converter

import (
	"bytes"
	"io"
	"strings"
	"testing"

	"github.com/handaber/cfg2env/plugin"
)

// mockPlugin implements plugin.Plugin for testing
type mockPlugin struct {
	plugin.BasePlugin
	parseFunc func(io.Reader) (map[string]string, error)
}

func (p *mockPlugin) Parse(r io.Reader) (map[string]string, error) {
	return p.parseFunc(r)
}

// testPlugin implements a simple plugin for testing
type testPlugin struct {
	plugin.BasePlugin
	data map[string]string
}

func (p *testPlugin) Parse(r io.Reader) (map[string]string, error) {
	return p.data, nil
}

func TestConverter_Convert(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    string
		wantErr bool
	}{
		{
			name:  "basic key-value pairs",
			input: "key=value",
			want:  "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=value\n",
		},
		{
			name:  "values with spaces",
			input: "key=value with spaces",
			want:  "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=value with spaces\n",
		},
		{
			name:  "empty values",
			input: "key=",
			want:  "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=\n",
		},
		{
			name:    "plugin error",
			input:   "error",
			wantErr: true,
		},
		{
			name:  "empty input",
			input: "",
			want:  "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\n",
		},
		{
			name:  "single character values",
			input: "k=v",
			want:  "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nK=v\n",
		},
		{
			name:  "mixed value types",
			input: "str=text\nnum=123\nbool=true",
			want:  "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nBOOL=true\nNUM=123\nSTR=text\n",
		},
		{
			name:    "case sensitivity - duplicate keys error",
			input:   "KEY=VALUE\nkey=value",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock plugin
			p := &mockPlugin{
				BasePlugin: plugin.NewBasePlugin("mock"),
				parseFunc: func(r io.Reader) (map[string]string, error) {
					if tt.input == "error" {
						return nil, io.ErrUnexpectedEOF
					}

					// Parse input into map
					env := make(map[string]string)
					for _, line := range strings.Split(tt.input, "\n") {
						if line == "" {
							continue
						}
						parts := strings.SplitN(line, "=", 2)
						if len(parts) == 2 {
							env[parts[0]] = parts[1]
						}
					}
					return env, nil
				},
			}

			// Create converter with mock plugin
			c := New(p)

			// Convert input
			var out bytes.Buffer
			err := c.Convert(strings.NewReader(tt.input), &out)

			// Check error
			if (err != nil) != tt.wantErr {
				t.Errorf("Convert() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}

			// Check output
			if got := out.String(); got != tt.want {
				t.Errorf("Convert() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestConverter_Convert_OutputFormatting(t *testing.T) {
	tests := []struct {
		name  string
		input map[string]string
		want  string
	}{
		{
			name: "special characters",
			input: map[string]string{
				"key": "value with spaces",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=value with spaces\n",
		},
		{
			name: "quotes in values",
			input: map[string]string{
				"key": `value with "quotes"`,
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=value with \"quotes\"\n",
		},
		{
			name: "multiple special chars",
			input: map[string]string{
				"key": `value with "quotes" and spaces`,
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=value with \"quotes\" and spaces\n",
		},
		{
			name: "all special characters",
			input: map[string]string{
				"key": `!@#$%^&*()_+-=[]{}|;:'",.<>?/~` + "`",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=!@#$%^&*()_+-=[]{}|;:'\",.<>?/~`\n",
		},
		{
			name: "unicode characters",
			input: map[string]string{
				"key": "value with 日本語",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=value with 日本語\n",
		},
		{
			name: "environment variable syntax",
			input: map[string]string{
				"key": "$HOME/path",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=$HOME/path\n",
		},
		{
			name: "shell special characters",
			input: map[string]string{
				"key": "$(command)",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nKEY=$(command)\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock plugin
			p := &mockPlugin{
				BasePlugin: plugin.NewBasePlugin("mock"),
				parseFunc: func(r io.Reader) (map[string]string, error) {
					return tt.input, nil
				},
			}

			// Create converter with mock plugin
			c := New(p)

			// Convert input
			var out bytes.Buffer
			err := c.Convert(strings.NewReader(""), &out)
			if err != nil {
				t.Fatalf("Convert() error = %v", err)
			}

			// Check output
			if got := out.String(); got != tt.want {
				t.Errorf("Convert() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestConverter_Convert_InputValidation(t *testing.T) {
	tests := []struct {
		name    string
		input   io.Reader
		output  io.Writer
		wantErr bool
	}{
		{
			name:    "nil input",
			input:   nil,
			output:  &bytes.Buffer{},
			wantErr: true,
		},
		{
			name:    "nil output",
			input:   strings.NewReader(""),
			output:  nil,
			wantErr: true,
		},
		{
			name:    "failing reader",
			input:   &failingReader{},
			output:  &bytes.Buffer{},
			wantErr: true,
		},
		{
			name:    "failing writer",
			input:   strings.NewReader("key=value"),
			output:  &failingWriter{},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock plugin
			p := &mockPlugin{
				BasePlugin: plugin.NewBasePlugin("mock"),
				parseFunc: func(r io.Reader) (map[string]string, error) {
					if _, ok := r.(*failingReader); ok {
						return nil, io.ErrUnexpectedEOF
					}
					return map[string]string{"key": "value"}, nil
				},
			}

			// Create converter with mock plugin
			c := New(p)

			// Convert input
			err := c.Convert(tt.input, tt.output)
			if (err != nil) != tt.wantErr {
				t.Errorf("Convert() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

// failingReader always returns an error on Read
type failingReader struct{}

func (r *failingReader) Read(p []byte) (n int, err error) {
	return 0, io.ErrUnexpectedEOF
}

// failingWriter always returns an error on Write
type failingWriter struct{}

func (w *failingWriter) Write(p []byte) (n int, err error) {
	return 0, io.ErrShortWrite
}

func TestConverterHeader(t *testing.T) {
	// Create a simple test plugin
	p := &testPlugin{
		BasePlugin: plugin.NewBasePlugin("test"),
		data: map[string]string{
			"key": "value",
		},
	}

	// Create converter with test version
	c := New(p)
	c.SetVersion("1.0.0-test")

	// Convert
	var buf bytes.Buffer
	if err := c.Convert(strings.NewReader(""), &buf); err != nil {
		t.Fatalf("Convert failed: %v", err)
	}

	// Get output lines
	output := buf.String()
	lines := strings.Split(output, "\n")

	// Check header
	expectedHeaders := []string{
		"# This file was auto-generated by cfg2env",
		"# Version: 1.0.0-test",
		"# Plugin: test",
		"#",
		"",
	}

	if len(lines) < len(expectedHeaders) {
		t.Fatalf("Output too short, got %d lines, want at least %d", len(lines), len(expectedHeaders))
	}

	for i, expected := range expectedHeaders {
		if lines[i] != expected {
			t.Errorf("Header line %d mismatch:\ngot:  %q\nwant: %q", i+1, lines[i], expected)
		}
	}

	// Verify the actual env content is still there
	found := false
	for _, line := range lines {
		if line == "KEY=value" {
			found = true
			break
		}
	}
	if !found {
		t.Error("Environment variable content not found in output")
	}
}

func TestConverter_DuplicateKeys(t *testing.T) {
	tests := []struct {
		name          string
		input         map[string]string
		wantErr       bool
		wantErrSubstr string
	}{
		{
			name: "case-insensitive duplicate",
			input: map[string]string{
				"KEY": "value1",
				"key": "value2",
			},
			wantErr:       true,
			wantErrSubstr: "duplicate key 'KEY' (found as 'KEY' and 'key')",
		},
		{
			name: "multiple case variants",
			input: map[string]string{
				"KEY": "value1",
				"key": "value2",
				"Key": "value3",
			},
			wantErr:       true,
			wantErrSubstr: "duplicate key 'KEY'",
		},
		{
			name: "no duplicates",
			input: map[string]string{
				"KEY1": "value1",
				"KEY2": "value2",
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &mockPlugin{
				BasePlugin: plugin.NewBasePlugin("mock"),
				parseFunc: func(r io.Reader) (map[string]string, error) {
					return tt.input, nil
				},
			}

			c := New(p)
			var out bytes.Buffer
			err := c.Convert(strings.NewReader(""), &out)

			if (err != nil) != tt.wantErr {
				t.Errorf("Convert() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr && tt.wantErrSubstr != "" {
				if err == nil || !strings.Contains(err.Error(), tt.wantErrSubstr) {
					t.Errorf("Convert() error = %v, want error containing %q", err, tt.wantErrSubstr)
				}
			}
		})
	}
}

func TestConverter_Dunder(t *testing.T) {
	tests := []struct {
		name   string
		dunder int
		input  map[string]string
		want   string
	}{
		{
			name:   "dunder 1 - single underscore",
			dunder: 1,
			input: map[string]string{
				"example_key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLEKEY=value\n",
		},
		{
			name:   "dunder 1 - double underscore",
			dunder: 1,
			input: map[string]string{
				"example__key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLE_KEY=value\n",
		},
		{
			name:   "dunder 1 - quadruple underscore",
			dunder: 1,
			input: map[string]string{
				"example____key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLE___KEY=value\n",
		},
		{
			name:   "dunder 3 - single underscore",
			dunder: 3,
			input: map[string]string{
				"example_key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLEKEY=value\n",
		},
		{
			name:   "dunder 3 - double underscore",
			dunder: 3,
			input: map[string]string{
				"example__key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLEKEY=value\n",
		},
		{
			name:   "dunder 3 - quadruple underscore",
			dunder: 3,
			input: map[string]string{
				"example____key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLE_KEY=value\n",
		},
		{
			name:   "negative dunder",
			dunder: -1,
			input: map[string]string{
				"example__key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLE__KEY=value\n",
		},
		{
			name:   "zero dunder",
			dunder: 0,
			input: map[string]string{
				"example__key": "value",
			},
			want: "# This file was auto-generated by cfg2env\n# Version: dev\n# Plugin: mock\n#\n\nEXAMPLE__KEY=value\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock plugin
			p := &mockPlugin{
				BasePlugin: plugin.NewBasePlugin("mock"),
				parseFunc: func(r io.Reader) (map[string]string, error) {
					return tt.input, nil
				},
			}

			// Create converter with mock plugin
			c := New(p)
			if tt.dunder > 0 {
				c.SetDunder(tt.dunder)
			}

			// Convert input
			var out bytes.Buffer
			err := c.Convert(strings.NewReader(""), &out)
			if err != nil {
				t.Fatalf("Convert() error = %v", err)
			}

			// Check output
			if got := out.String(); got != tt.want {
				t.Errorf("Convert() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestConverterWithFilter(t *testing.T) {
	tests := []struct {
		name    string
		input   map[string]string
		include []string
		exclude []string
		want    []string // expected keys in output
	}{
		{
			name: "include only DATABASE keys",
			input: map[string]string{
				"database_host": "localhost",
				"database_port": "5432",
				"api_host":      "api.example.com",
				"cache_host":    "redis.local",
			},
			include: []string{"DATABASE_*"},
			want:    []string{"DATABASE_HOST", "DATABASE_PORT"},
		},
		{
			name: "exclude sensitive keys",
			input: map[string]string{
				"database_host":     "localhost",
				"database_password": "secret",
				"api_host":          "api.example.com",
				"api_token":         "token123",
				"cache_host":        "redis.local",
			},
			exclude: []string{"*_PASSWORD", "*_TOKEN"},
			want:    []string{"API_HOST", "CACHE_HOST", "DATABASE_HOST"},
		},
		{
			name: "include DATABASE, exclude passwords",
			input: map[string]string{
				"database_host":     "localhost",
				"database_password": "secret",
				"database_port":     "5432",
				"api_host":          "api.example.com",
			},
			include: []string{"DATABASE_*"},
			exclude: []string{"*_PASSWORD"},
			want:    []string{"DATABASE_HOST", "DATABASE_PORT"},
		},
		{
			name: "multiple include patterns",
			input: map[string]string{
				"database_host": "localhost",
				"api_host":      "api.example.com",
				"cache_host":    "redis.local",
				"log_level":     "info",
			},
			include: []string{"DATABASE_*", "API_*"},
			want:    []string{"API_HOST", "DATABASE_HOST"},
		},
		{
			name: "multiple exclude patterns",
			input: map[string]string{
				"database_host":     "localhost",
				"database_password": "secret",
				"api_token":         "token123",
				"api_secret":        "secret456",
				"cache_host":        "redis.local",
			},
			exclude: []string{"*_PASSWORD", "*_TOKEN", "*_SECRET"},
			want:    []string{"CACHE_HOST", "DATABASE_HOST"},
		},
		{
			name: "pattern normalization - lowercase pattern",
			input: map[string]string{
				"DATABASE_HOST": "localhost",
				"API_HOST":      "api.example.com",
			},
			include: []string{"database_*"},
			want:    []string{"DATABASE_HOST"},
		},
		{
			name: "pattern normalization - mixed case pattern",
			input: map[string]string{
				"database_host": "localhost",
				"api_host":      "api.example.com",
			},
			include: []string{"Database_*"},
			want:    []string{"DATABASE_HOST"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock plugin
			p := &mockPlugin{
				BasePlugin: plugin.NewBasePlugin("mock"),
				parseFunc: func(r io.Reader) (map[string]string, error) {
					return tt.input, nil
				},
			}

			// Create converter and set filter
			c := New(p)
			if len(tt.include) > 0 || len(tt.exclude) > 0 {
				c.SetFilterPatterns(tt.include, tt.exclude, GlobMatcher{})
			}

			// Convert
			var out bytes.Buffer
			err := c.Convert(strings.NewReader(""), &out)
			if err != nil {
				t.Fatalf("Convert() error = %v", err)
			}

			// Parse output
			lines := strings.Split(out.String(), "\n")
			var gotKeys []string
			for _, line := range lines {
				if line == "" || strings.HasPrefix(line, "#") {
					continue
				}
				parts := strings.SplitN(line, "=", 2)
				if len(parts) == 2 {
					gotKeys = append(gotKeys, parts[0])
				}
			}

			// Verify keys match expected
			if len(gotKeys) != len(tt.want) {
				t.Errorf("got %d keys, want %d\ngot:  %v\nwant: %v", len(gotKeys), len(tt.want), gotKeys, tt.want)
				return
			}

			// Check each expected key is present
			gotMap := make(map[string]bool)
			for _, k := range gotKeys {
				gotMap[k] = true
			}
			for _, wantKey := range tt.want {
				if !gotMap[wantKey] {
					t.Errorf("missing key %q in output", wantKey)
				}
			}
		})
	}
}

func TestConverterWithFilterNoMatches(t *testing.T) {
	input := map[string]string{
		"database_host": "localhost",
		"database_port": "5432",
		"api_host":      "api.example.com",
	}

	tests := []struct {
		name    string
		include []string
		exclude []string
	}{
		{
			name:    "include pattern matches nothing",
			include: []string{"NONEXISTENT_*"},
		},
		{
			name:    "exclude all keys",
			exclude: []string{"*"},
		},
		{
			name:    "include matches but exclude removes all",
			include: []string{"DATABASE_*"},
			exclude: []string{"DATABASE_*"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock plugin
			p := &mockPlugin{
				BasePlugin: plugin.NewBasePlugin("mock"),
				parseFunc: func(r io.Reader) (map[string]string, error) {
					return input, nil
				},
			}

			// Create converter and set filter
			c := New(p)
			c.SetFilterPatterns(tt.include, tt.exclude, GlobMatcher{})

			// Convert
			var out bytes.Buffer
			err := c.Convert(strings.NewReader(""), &out)
			if err != nil {
				t.Fatalf("Convert() error = %v", err)
			}

			// Verify output contains header and no-match comment
			output := out.String()
			if !strings.Contains(output, "# This file was auto-generated by cfg2env") {
				t.Error("output missing header")
			}
			if !strings.Contains(output, "# No keys matched the specified filters") {
				t.Error("output missing no-match comment")
			}

			// Verify no key-value pairs in output
			lines := strings.Split(output, "\n")
			for _, line := range lines {
				if line != "" && !strings.HasPrefix(line, "#") {
					t.Errorf("unexpected non-comment line in output: %q", line)
				}
			}
		})
	}
}
