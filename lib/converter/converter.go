package converter

import (
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/handaber/cfg2env/plugin"
)

// Converter handles the conversion of configuration files to .env format
type Converter struct {
	plugin  plugin.Plugin
	version string
	dunder  int
	filter  *filter
}

// New creates a new Converter with the given plugin
func New(p plugin.Plugin) *Converter {
	return &Converter{
		plugin:  p,
		version: "dev", // This will be overridden by the version from main
		dunder:  0,
	}
}

// SetVersion sets the version string for the converter
func (c *Converter) SetVersion(version string) {
	c.version = version
}

// SetDunder sets the number of underscores to remove from consecutive sequences
func (c *Converter) SetDunder(n int) {
	if n > 0 {
		c.dunder = n
	}
}

// processKey processes the key according to dunder rules
func (c *Converter) processKey(key string) string {
	if c.dunder == 0 {
		return key
	}

	var result strings.Builder
	underscoreCount := 0

	for _, char := range key {
		if char == '_' {
			underscoreCount++
		} else {
			if underscoreCount > 0 {
				// If we have consecutive underscores, remove up to dunder count
				remaining := underscoreCount - c.dunder
				if remaining > 0 {
					result.WriteString(strings.Repeat("_", remaining))
				}
				underscoreCount = 0
			}
			result.WriteRune(char)
		}
	}

	// Handle trailing underscores
	if underscoreCount > 0 {
		remaining := underscoreCount - c.dunder
		if remaining > 0 {
			result.WriteString(strings.Repeat("_", remaining))
		}
	}

	return result.String()
}

func (c *Converter) writeHeader(w io.Writer) error {
	header := []string{
		"# This file was auto-generated by cfg2env",
		fmt.Sprintf("# Version: %s", c.version),
		fmt.Sprintf("# Plugin: %s", c.plugin.Name()),
		"#",
		"",
	}

	for _, line := range header {
		if _, err := io.WriteString(w, line+"\n"); err != nil {
			return fmt.Errorf("writing header error: %w", err)
		}
	}
	return nil
}

// Convert reads from r and writes the converted output to w
func (c *Converter) Convert(r io.Reader, w io.Writer) error {
	// Handle nil input/output
	if r == nil {
		return fmt.Errorf("input reader is nil")
	}
	if w == nil {
		return fmt.Errorf("output writer is nil")
	}

	// Write header first
	if err := c.writeHeader(w); err != nil {
		return err
	}

	// Parse input using plugin
	env, err := c.plugin.Parse(r)
	if err != nil {
		return fmt.Errorf("parsing error: %w", err)
	}

	// Convert all keys to uppercase and detect duplicates
	normalized := make(map[string]string)
	keyMapping := make(map[string][]string) // maps uppercase key to original keys

	for k := range env {
		upperKey := strings.ToUpper(k)
		processedKey := c.processKey(upperKey)
		keyMapping[processedKey] = append(keyMapping[processedKey], k)
	}

	// Check for duplicates
	var exactDuplicates []string
	var caseInsensitiveDuplicates []string

	for upperKey, originalKeys := range keyMapping {
		if len(originalKeys) > 1 {
			// Check if it's an exact duplicate or case-insensitive duplicate
			allSame := true
			for i := 1; i < len(originalKeys); i++ {
				if originalKeys[i] != originalKeys[0] {
					allSame = false
					break
				}
			}

			if allSame {
				exactDuplicates = append(exactDuplicates, fmt.Sprintf("duplicate key '%s'", originalKeys[0]))
			} else {
				// Sort for consistent error messages
				sortedKeys := make([]string, len(originalKeys))
				copy(sortedKeys, originalKeys)
				sort.Strings(sortedKeys)
				caseInsensitiveDuplicates = append(caseInsensitiveDuplicates,
					fmt.Sprintf("duplicate key '%s' (found as '%s')", upperKey, strings.Join(sortedKeys, "' and '")))
			}
		} else {
			// No duplicate, add to normalized map
			normalized[upperKey] = env[originalKeys[0]]
		}
	}

	// Report all duplicates if any found
	if len(exactDuplicates) > 0 || len(caseInsensitiveDuplicates) > 0 {
		var errMsg strings.Builder
		errMsg.WriteString("duplicate keys found: ")

		allErrors := append(exactDuplicates, caseInsensitiveDuplicates...)
		sort.Strings(allErrors)
		errMsg.WriteString(strings.Join(allErrors, "; "))

		return fmt.Errorf(errMsg.String())
	}

	// Apply filter if configured
	if c.filter != nil {
		filtered := make(map[string]string)
		for k, v := range normalized {
			if c.filter.shouldInclude(k) {
				filtered[k] = v
			}
		}
		normalized = filtered

		// Handle empty result
		if len(normalized) == 0 {
			_, err := io.WriteString(w, "# No keys matched the specified filters\n")
			return err
		}
	}

	// Get sorted keys for consistent output
	var keys []string
	for k := range normalized {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Write output in .env format
	for _, k := range keys {
		if _, err := io.WriteString(w, k+"="+normalized[k]+"\n"); err != nil {
			return fmt.Errorf("writing error: %w", err)
		}
	}

	return nil
}
